<html>
<HEAD>
   <TITLE> Почему криптосистемы ненадежны?
 </TITLE>
   <META NAME="Author" CONTENT="Sergey Protasov ">
   <META NAME="KeyWords" CONTENT=" hack, crack, ИБЛЕТ, троян, хакер, взлом, вирус, _El, Протасов, Сергей, FAQ, Soft, exploit ">
   <META NAME="Description" CONTENT="">
</HEAD>
<BODY TEXT="#000000" LINK="#0066CC" VLINK="#993366" BACKGROUND="bgtext.gif">
<table width=120 align=left>
  <tr><td>     <pre>
 <br>
 <br>
 <br>
 <br>
</pre>
  </td></tr>
  <tr>
    <td valign=top width="120">
           <table width=120 cellspacing=0 cellpadding=0 border=2 bgcolor="#949cc6">
     <tr>
       <td>
          <table width="100%" border="1" cellspacing="0" cellpadding="0">
             <tr><td></td></tr>
          </table>
          <table width="100%" border="0" cellspacing="0" cellpadding="0" bgcolor="#f0DEe7">
          <tr>
             <td><img src="empty.gif" width=3 height=8 border=0 alt="">
             </td>
             <td>
             <table width=120 border="0" cellspacing="0" cellpadding="0" align="LEFT" valign="TOP">
               <tr>
                 <td valign="TOP"><font color="#ff4000">&#0149;</font>
                 </td>
                 <TD ALIGN=left VALIGN=top WIDTH=90%><FONT SIZE=-1>
                    <a style="color=#ff4000" href="security_.html"><font color="#ff4000">Security Page</font></A></FONT>
                 </TD>
               </tr>
               <tr>
                 <td valign="TOP"><font color="#ff4000">&#0149;</font>
                 </td>
                 <TD ALIGN=left VALIGN=top WIDTH=90%><FONT SIZE=-1>
                    <a style="color=#ff4000" href="news_.html"><font color="#ff4000">Security News</font></A></FONT>
                 </TD>
               </tr>
               <tr>
                 <td valign="TOP"><font color="#ff4000">&#0149;</font>
                 </td>
                 <TD ALIGN=left VALIGN=top WIDTH=90%><FONT SIZE=-1>
                    <a style="color=#ff4000" href="security_unix_.html"><font color="#ff4000">Безопасность в Unix</font></A></FONT>
                 </TD>
               </tr>
               <tr>
                 <td valign="TOP"><font color="#ff4000">&#0149;</font>
                 </td>
                 <TD ALIGN=left VALIGN=top WIDTH=90%><FONT SIZE=-1>
                    <a style="color=#ff4000" href="security_nt_.html"><font color="#ff4000">Безопасность в Windows</font></A></FONT>
                 </TD>
               </tr>
               <tr>
                 <td valign="TOP"><font color="#ff4000">&#0149;</font>
                 </td>
                 <TD ALIGN=left VALIGN=top WIDTH=90%><FONT SIZE=-1>
                    <a style="color=#ff4000" href="security_faqs_.html"><font color="#ff4000">Сборник FAQ'ов</font></A></FONT>
                 </TD>
               </tr>
               <tr>
                 <td valign="TOP"><font color="#ff4000">&#0149;</font>
                 </td>
                 <TD ALIGN=left VALIGN=top WIDTH=90%><FONT SIZE=-1>
                    <a style="color=#ff4000" href="phreaking_.html"><font color="#ff4000">Телефония, фрикинг</font></A></FONT>
                 </TD>
               </tr>
               <tr>
                 <td valign="TOP"><font color="#ff4000">&#0149;</font>
                 </td>
                 <TD ALIGN=left VALIGN=top WIDTH=90%><FONT SIZE=-1>
                    <a style="color=#ff4000" href="carding_.html"><font color="#ff4000">Кредитные карты</font></A></FONT>
                 </TD>
               </tr>
               <tr>
                 <td valign="TOP"><font color="#ff4000">&#0149;</font>
                 </td>
                 <TD ALIGN=left VALIGN=top WIDTH=90%><FONT SIZE=-1>
                    <a style="color=#ff4000" href="crypto_.html"><font color="#ff4000">Криптография</font></A></FONT>
                 </TD>
               </tr>
               <tr>
                 <td valign="TOP"><font color="#ff4000">&#0149;</font>
                 </td>
                 <TD ALIGN=left VALIGN=top WIDTH=90%><FONT SIZE=-1>
                    <a style="color=#ff4000" href="security_history_.html"><font color="#ff4000">Истории о хакерах</font></A></FONT>
                 </TD>
               </tr>
               <tr>
                 <td valign="TOP"><font color="#ff4000">&#0149;</font>
                 </td>
                 <TD ALIGN=left VALIGN=top WIDTH=90%><FONT SIZE=-1>
                    <a style="color=#ff4000" href="download_.html"><font color="#ff4000">Программы, утилиты</font></A></FONT>
                 </TD>
               </tr>
               <tr>
                 <td valign="TOP"><font color="#ff4000">&#0149;</font>
                 </td>
                 <TD ALIGN=left VALIGN=top WIDTH=90%><FONT SIZE=-1>
                    <a style="color=#ff4000" href="scripts_.html"><font color="#ff4000">CGI скрипты</font></A></FONT>
                 </TD>
               </tr>
             </table>
             </td>
          </tr>
          <tr>
             <td colspan="2"><img src="empty.gif" width=1 height=3 border=0 alt=""> 
             </td>
          </tr>
          </table>
          <table width="100%" border="1" cellspacing="0" cellpadding="0">
             <tr><td>
             </td></tr>
          </table>
          <table width="100%" border="0" cellspacing="0" cellpadding="0">
             <tr>
                <td>
                   <table width="100%" height=20 border="0" cellspacing="0" cellpadding="0">
                      <tr>
                         <td><img src="empty.gif" width=5 height=1 border=0 alt="">
                         </td>
                         <td> <font size="-1"><b><a style="color=#000080" href=http://www.svp.lgg.ru/home_.html><font color="#000080">_el@geocities.com</font></a></b></font>
                         </td>
                      </tr>
                   </table>
                </td>
             </tr>
          </table>
      </td>
  </tr>
</table>
      
      
    </td>
  </tr>
</table>
<table width=600 ALIGN=center VALIGN=middle>
   <tr>
      <td align=center valign=middle WIDTH=20>
                    <img src="empty.gif" width=10 height=10 border=0 alt="">
       </td>
       <td>
<table border="0" WIDTH=110>
    <tr>
        <td  align=left width=110>
        </td>
    </tr>
</table>
<table border="0" WIDTH=100%>
    <tr>
        <td valign=top  align=center width=100%>
        <CENTER>
        <!-- Russian LinkExchange code START -->
        <center><table><tr><td align="center">
        <a href="http://www.linkexchange.ru/users/000732/goto.map" target="_top">
         <img ismap src="http://www.linkexchange.ru/cgi-bin/rle.cgi?732?1" alt="Russian LinkExchange Advertising Network" border="0" height="60" width="468"></a>
        </td></tr>
        <tr><td align="center"><font size="2"><a href="http://www.linkexchange.ru" >Russian LinkExchange Member</a></font></td></tr></table></center>
        <!-- Russian LinkExchange code END -->
        </CENTER>
        </td>
    </tr>
</table>
<hr width=100%>
               <h2 align=center> Почему криптосистемы ненадежны?
 </h2>


       <pre>
</pre>
<p class="l" align="left">
Павел Семьянов, <a href="http://www.ssl.stu.neva.ru">Центр Защиты Информации СПбГТУ</i></a>

<P>В современном программном обеспечении <I>(ПО) </I>криптоалгоритмы широко
применяются не только для задач шифрования данных, но и для аутентификации
и проверки целостности. На сегодняшний день существуют хорошо известные
и апробированные криптоалгоритмы (как с симметричными, так и несимметричными
ключами), криптостойкость которых либо доказана математически, либо основана
на необходимости решения математически сложной задачи (факторизации, дискретного
логарифмирования и т.п.). К наиболее известным из них относятся<I> <A HREF="http://www.rsa.com/rsalabs/newfaq/q64.html">DES</A>,
<A HREF="http://www.jetico.sci.fi/gost.htm">ГОСТ</A>, <A HREF="http://www.rsa.com/rsalabs/newfaq/q8.html">RSA</A>.
</I>Таким образом, они не могут быть вскрыты иначе, чем полным перебором
или решением указанной задачи.</P>

<P>С другой стороны, в компьютерном и околокомпьютерном мире все время
появляется информация об ошибках или &quot;дырах&quot; в той или иной программе
(в т.ч. применяющей криптоалгоритмы), или о том, что она была взломана
(<I>cracked</I>). Это создает недоверие как к конкретным программам, так
и к возможности вообще защитить что-либо криптографичеcкими методами не
только от спецслужб, но и от простых хакеров.</P>

<P>Поэтому знание истории атак и &quot;дыр&quot; в криптосистемах, а также
понимание причин, по которым они имели место, является одним из необходимых
условий разработки защищенных систем. Перспективным направлением исследований
в этой области является анализ успешно проведенных атак или выявленных
уязвимостей в криптосистемах с целью их обобщения, классификации и выявления
причин и закономерностей их появления и существования. Это и будет являться
задачей данной статьи.</P>

<P>По аналогии с таксономией причин нарушения безопасности ВС [<A HREF="#l1" target="_self">1</A>],
выделим следующие причины ненадежности криптографических программ (см.
рис. 1):</P>

<OL>
<OL>
<LI><A HREF="#impossibility" target="_self">Невозможность применения стойких криптоалгоритмов</A>;</LI>

<LI><A HREF="#realization" target="_self">Ошибки в реализации криптоалгоритмов</A>;</LI>

<LI><A HREF="#using" target="_self">Неправильное применение криптоалгоритмов</A>;</LI>

<LI><A HREF="#human" target="_self">Человеческий фактор</A>.</LI>
</OL>
</OL>

<P>Отметим сразу, что рассматриваемые ниже причины покрывают только два
вида потенциально возможных угроз: <I>раскрытия</I> и <I>целостности</I>,
оставляя в стороне угрозу <I>отказа в обслуживании</I>, которая приобретает
все большее значение по мере развития распределенных криптосистем.</P>
</blockquote>
<p class="c"><IMG SRC="Image1.gif" ALT="Fig.1" HEIGHT=1104 WIDTH=779></P>
<blockquote>

<DD><B>Рис. 1. Причины ненадежности криптосистем.</B></DD>

<H2><A NAME="impossibility"></A><B>Невозможность применения стойких криптоалгоритмов</B></H2>

<P>Эта группа причин является наиболее распространенной из-за следующих
факторов.</P>

<H3><B><I>Малая скорость стойких криптоалгоритмов</I></B></H3>

<P>Это основной фактор, затрудняющий применение хороших алгоритмов в, например,
системах &quot;тотального&quot; шифрования или шифрования &quot;на лету&quot;.
В частности, программа<B> </B><TT>Norton DiskReet</TT>, хотя и имеет реализацию
<I>DES</I>, при смене пользователем ключа может не перешифровывать весь
диск, т.к. это займет слишком много времени. Аналогично, программа компрессии
&quot;на лету&quot; <TT>Stacker</TT><I> </I>фирмы <I><A HREF="http://www.stac.com/">Stac
Electronics</A></I> имеет опцию закрытия паролем компрессируемых данных.
Однако она не имеет физической возможности зашифровать этим паролем свой
файл, обычно имеющий размеры в несколько сот мегабайт, поэтому она ограничивается
очень слабым алгоритмом и хранит хэш-функцию от пароля вместе с защищаемыми
данными. Величина криптостойкости<SUP><A HREF="#s9" target="_self">1</A></SUP> этой функции
была исследована и оказалась равной 2<SUP>8</SUP>, т.е. пароль может быть
вскрыт <A HREF="http://www.ssl.stu.neva.ru/psw/DOWNLOAD/stacpswd.com">тривиально</A>.</P>

<H3><I>Экспортные ограничения</I></H3>

<P>Это причина, связанная с экспортом криптоалгоритмов или с необходимостью
приобретать патент или права на них. В частности, из США запрещен <A HREF="http://www.cypher.net/info/itar.html">экспорт
криптоалгоритмов</A> с длиной ключа более 40 бит<SUP><A HREF="#s1" target="_self">2</A></SUP>.
Очевидно, что такая криптостойкость не может считаться надежной при современных
вычислительных мощностях и даже на персональном компьютере, положив скорость
перебора в 50 000 паролей/сек, получим время перебора в среднем порядка
4 месяцев.</P>

<P>Известные примеры программ, подверженных экспортным ограничениям - это
последние версии <I>броузеров (browser) </I>Интернета, в частности <TT>Netscape
Navigator</TT>фирмы <I><A HREF="http://home.netscape.com">Netscape Communications</A></I>
и <TT>Internet Explorer </TT>фирмы <I><A HREF="http://www.microsoft.com">Microsoft</A></I>.
Они предоставляют шифрование со 128-битным ключом для пользователей внутри
США и с 40-битным ключом для всех остальных.</P>

<P>Также в эту группу попадает последняя версия архиватора <TT><A HREF="http://www.arjsoftware.com">ARJ
2.60</A></TT>, известного своим слабым алгоритмом шифрования архивов. Теперь
пользователи внутри США могут использовать криптостойкий алгоритм ГОСТ.
Комизм ситуации в том, что хотя этот алгоритм является российским, даже
россияне по законам США все равно не могут воспользоваться им в программе
ARJ.</P>

<H3><I>Использование собственных криптоалгоритмов</I></H3>

<P>Незнание или нежелание использовать известные алгоритмы - такая ситуация,
как ни парадоксально, также имеет место быть, особенно в программах типа
Freeware и Shareware, например, архиваторах. </P>

<P>Как уже говорилось, архиватор ARJ (до версии 2.60 включительно) использует
(по умолчанию) очень слабый алгоритм шифрования - простое гаммирование.
Казалось бы, что в данном случае использование его допустимо, т.к. архивированный
текст должен быть совершенно неизбыточен и статистические методы криптоанализа
здесь не подходят. Однако, после более детального изучения оказалось, что
в архивированном тексте присутствует (и это оказывается справедливым для
любых архиваторов) некоторая неслучайная информация - например, таблица
Хаффмана и некоторая другая служебная информация. Поэтому, точно зная или
предсказав с некоторой вероятностью значение этих служебных переменных,
можно с той же вероятностью определить и соответствующие символы пароля.</P>

<P>Далее, использование слабых алгоритмов часто приводит к успеху <I>атаки
по открытому тексту</I>. В случае архиватора ARJ, если злоумышленнику известен
хотя бы один файл из зашифрованного архива, он с легкостью <A HREF="http://www.ssl.stu.neva.ru/psw/DOWNLOAD/solvepwd.com">определит</A>
пароль архива и извлечет оттуда все остальные файлы (криптостойкость ARJ<TT>
</TT>при наличии открытого текста - 2<SUP>0 </SUP>!). Даже если ни одного
файла в незашифрованном виде нет, то все равно простое гаммирование позволяет
<A HREF="http://www.ssl.stu.neva.ru/psw/DOWNLOAD/yaac096.arj">достичь</A>
скорости перебора в 350000 паролей/сек. на машине класса Pentium.</P>

<P>Аналогичная ситуация имеет место и в случае с популярными программами
из <TT><A HREF="http://www.microsoft.com/office">Microsoft Office</A></TT>
- для <A HREF="http://194.85.96.197/psw/DOWNLOAD/msof0104.zip">определения</A>
пароля там необходимо знать всего 16 байт файла <TT>.doc</TT> или <TT>.xls</TT>,
после чего достаточно перебрать всего 2<SUP>4</SUP> вариантов. В Microsoft
Office 97 сделаны значительные улучшения алгоритмов шифрования, в результате
чего осталась возможность только полного перебора, но... не везде - <A HREF="http://www.microsoft.com/access/">MS
Access 97</A> использует примитивнейший алгоритм, причем шифруются не данные,
а сам пароль операцией XOR с фиксированной константой!</P>

<P><A NAME="novell"></A>В сетевой ОС<I> </I><TT>Novell Netware</TT><I>
</I>фирмы <I><A HREF="http://www.novell.com">Novell</A> </I>(версии 3.х
и 4.х) также применяется собственный алгоритм <A HREF="http://www.ssl.stu.neva.ru/ssl/prg/logintof.c">хэширования</A>.
На входе хэш-функция получает 32-байтовое значение, полученное из оригинального
пароля пользователя путем либо сжатия пароля длиной более 32 символов с
помощью операции XOR, либо размножением пароля длиной менее 32 символов;
а на выходе - 16-байтовое хэш-значение (<I>Hash16</I>). Именно оно (для
Novell Netware 3.х) хранится в базе данных связок <I>(bindery)</I> в виде
свойства <I>&quot;PASSWORD&quot;</I>.</P>

<P>Одним из основных свойств криптостойкой хэш-функции должно быть то,
что она не должна допускать легкого построения коллизий (таковой, например,
является функция <I>crypt(), </I>используемая в UNIX, которая основана
на DES). Именно это свойство нарушено в хэш-функции, применяемой в Novell
Netware.</P>

<P>Была построена <A HREF="http://www.ssl.stu.neva.ru/ssl/prg/npg.exe">процедура</A>,
которая из данного хэш-значения путем небольшого перебора (несколько секунд
на машине класса 80486DX2-66) получает 32-байтовую последовательность,
которая, конечно, не является истинным паролем, но тем не менее воспринимается
Novell Netware как таковой, т.к. применение к ней хэш-алгоритма, выдает
в точности имеющееся хэш-значение. </P>

<P>Рассмотренный хэш-алгоритм остался и в 4 версии Novell Netware.</P>

<P>В свою очередь, фирма Microsoft также имеет серьезнейшие недостатки
в своем основном хэш-алгоритме, применяемом во всех своих ОС, начиная с
Windows 3.11, при аутентификации в локальных (протокол NetBIOS) и глобальных
(протоколы CIFS и http) сетях, называемым LM (Lan Manager)-хэш [<A HREF="#l4" target="_self">4</A>].
(Впрочем, Microsoft ссылается на то, что он остался еще со времен OS/2
и что его разрабатывала IBM).</P>

<P>Он вычисляется следующим образом:</P>

<OL>
<LI>Пароль превращается в 14-символьную строку путем либо отсечки болеет
длинных паролей, либо дополнения коротких паролей нулевыми элементами.</LI>

<LI>Все символы нижнего регистра заменяются на символы верхнего регистра.
Цифры и специальные символы остаются без изменений.</LI>

<LI>14-байтовая строка разбивается на две семибайтовых половины.</LI>

<LI>Используя каждую половину строки в роли ключа DES, с ним шифруется
фиксированная константа, получая на выходе две 8-байтовые строки.</LI>

<LI>Эти строки сливаются для создания 16-разрядного значения хэш-функции.
</LI>
</OL>

<P>Очевидно, что атаки на LM-хэш легко достигают успеха по следующим причинам:</P>

<UL>
<LI>Преобразование всех символов в верхний регистр ограничивает и без того
небольшое число возможных комбинаций для каждого (26+10+32=68).</LI>

<LI>Две семибайтовых &quot;половины&quot; пароля хэшируются независимо
друг от друга. Таким образом, две половины могут подбираться перебором
независимо друг от друга, и пароли, длина которых превышает семь символов,
не сильнее, чем пароли с длиной семь символов. Таким образом, для гарантированного
нахождения пароля необходимо перебрать вместо 94<SUP>0</SUP>+94<SUP>1</SUP>+...
94<SUP>14</SUP> ~4·10<SUP>27</SUP> всего лишь 2·(68<SUP>0</SUP>+68<SUP>1</SUP>+...+68<SUP>7</SUP>)
~1·10<SUP>13</SUP> (т.е. почти в 10<SUP>14</SUP> раз меньше) комбинаций.
Кроме того, те пароли, длина которых не превышает семь символов, очень
просто распознать, поскольку вторая половина хэша будет одним и тем же
значением <I>AAD3B435B51404EE</I>, получаемой при шифровании фиксированной
константы с помощью ключа из семи нулей.</LI>

<LI>Нет элемента случайности <I>(salt)</I>, как это сделано в crypt() -
два пользователя с одинаковыми паролями всегда будут иметь одинаковые значения
хэш-функции. Таким образом, можно заранее составить словарь хэшированных
паролей и осуществлять поиск неизвестного пароля в нем. </LI>
</UL>

<H2><A NAME="realization"></A><B>Неправильная реализация криптоалгоритмов</B></H2>

<P>Несмотря на то, что в этом случае применяются криптостойкие или сертифицированные
алгоритмы, эта группа причин приводит к нарушениям безопасности криптосистем
из-за их неправильной реализации.</P>

<H3><I>Уменьшение криптостойкости при генерации ключа</I></H3>

<P>Эта причина с весьма многочисленными примерами, когда криптосистема
либо обрезает пароль пользователя, либо генерирует из него данные, имеющие
меньшее количество бит, чем сам пароль. Примеры:</P>

<OL>
<LI>Во многих (старых) версиях UNIX пароль пользователя обрезается до 8
байт перед хэшированием. Любопытно, что, например, <TT>Linux 2.0</TT>,
требуя от пользователей ввода паролей, содержащих обязательно буквы и цифры,
не проверяет, чтобы 8-символьное начало пароля также состояло из букв и
цифр. Поэтому пользователь, задав, например, достаточно надежный пароль
<I>passwordIsgood19</I>, будет весьма удивлен, узнав, что хакер вошел в
систему под его именем с помощью элементарного пароля <I>password</I>.</LI>

<LI>Novell Netware позволяет пользователям иметь пароли до 128 байт, что
дает (считая латинские буквы без учета регистра, цифры и спецсимволы) 68<SUP>128
</SUP>~2<SUP>779 </SUP>комбинаций. Но при этом, во-первых, хэш-функция
(см. <A HREF="#novell" target="_self">выше</A>) получает на входе всего лишь 32-байтовое
значение, что ограничивает эффективную длину пароля этой же величиной.
Более того, во-вторых, на выходе хэш-значение имеет длину всего 128 бит,
что соответствует 2<SUP>128</SUP> комбинаций. Это дополнительно снижает
эффективную длину до <IMG SRC="Image2.gif" ALT="log68(2^128)" HEIGHT=36 WIDTH=90 ALIGN=ABSCENTER>=21
символа<SUP><A HREF="#s2" target="_self">3</A></SUP>, т.е. в 6 раз по сравнению с первоначальной.</LI>

<LI>Полностью аналогичная ситуация происходит с архиватором <TT><A HREF="http://www.creabel.com/softronic/rar_archiver.htm">RAR</A></TT>
версий 1.5x - выбор пароля больше 10 символов не приводит к росту времени,
необходимого на его вскрытие.</LI>
</OL>

<P>Если длина пароля &quot;сверху&quot; в этом случае определяется реализацией
криптоалгоритмов, то ограничение на длину &quot;снизу&quot; уже связано
с понятием единицы информации или энтропии. В рассмотренном примере с Novell
Netware для создания хэш-значения с энтропией 128 бит длина пароля должна
быть не менее <IMG SRC="Image3.gif" ALT="128 * (8/log2(68))" HEIGHT=63 WIDTH=120 ALIGN=ABSCENTER>=69
бит<SUP><A HREF="#s3" target="_self">4</A></SUP> или не менее 22 символов<SUP><A HREF="#s4" target="_self">5</A></SUP>.
То, что многие криптосистемы не ограничивают минимальную длину пароля,
как раз и приводит к успеху <A HREF="#human" target="_self">атак перебором</A> не ключей,
а паролей.</P>

<H3><I>Отсутствие проверки на слабые ключи</I></H3>

<P>Некоторые криптоалгоритмы (в частности, DES, IDEA) при шифровании со
специфическими ключами не могут обеспечить должный уровень криптостойкости.
Такие ключи называют слабыми <I>(weak). </I>Для DES известно 4 слабых и
12 полуслабых <I>(semi-weak)</I> ключей. И хотя вероятность попасть в них
равняется <IMG SRC="Image4.gif" ALT="16/2^56" HEIGHT=51 WIDTH=34 ALIGN=ABSCENTER>~2·10<SUP>-16</SUP>,
для серьезных криптографических систем пренебрегать ей нельзя.</P>

<P>Мощность множества слабых ключей <A HREF="http://www.rsa.com/rsalabs/newfaq/q77.html">IDEA
</A>составляет не много - не мало - 2<SUP>51</SUP> (впрочем, из-за того,
что всего ключей 2<SUP>128</SUP>, вероятность попасть в него в 3·10<SUP>7
</SUP>раз меньше, чем у DES).</P>

<H3><I>Недостаточная защищенность от РПС</I></H3>

<P>РПС (разрушающие программные средства) - это компьютерные вирусы, троянских
кони, программные закладки и т.п. программы, способные перехватить секретный
ключ или сами нешифрованные данные, а также просто подменить алгоритм на
некриптостойкий. В случае, если программист не предусмотрел достаточных
способов защиты от РПС, они легко способны нарушить безопасность криптосистемы.
Особенно это актуально для операционных систем, не имеющих встроенных средств
защиты или средств разграничения доступа - типа MS DOS или Windows 95:</P>

<OL>
<LI><I>Перехват пароля.</I> Как пример можно привести самый старый способ
похищения пароля, известный еще со времен больших ЭВМ, когда программа-&quot;фантом&quot;
эмулирует приглашение ОС, предлагая ввести имя пользователя и пароль, запоминает
его в некотором файле и прекращает работу с сообщением <I>&quot;Invalid
password&quot;</I>. Для MS DOS и Windows существует множество закладок
для чтения и сохранения паролей, набираемых на клавиатуре (через перехват
соответствующего прерывания), например, при работе утилиты <TT>Diskreet
v. 6.0.</TT></LI>

<LI><I>Подмена криптоалгоритма. </I>Примером реализации этого случая является
закладка, маскируемая под прикладную программу-&quot;ускоритель&quot; типа
<I>Turbo Krypton</I>. Эта закладка заменяет алгоритм шифрования ГОСТ 28147-89,
реализуемой платой <I>&quot;Krypton-3&quot;</I> (демонстрационный вариант),
другим, простым и легко дешифруемым алгоритмом [<A HREF="#l1" target="_self">1</A>].</LI>

<LI><I>Троянский конь в электронной почте.</I> Последним <A HREF="http://www.avp.ru/russian/news/press/newvir.htm">примером</A>
служит имевшие место в июне 1998 года попытки проникновения троянского
коня через электронную почту. В письмо были вложены порнографическая картинка
и EXE-файл FREECD.EXE, который за то время, пока пользователь развлекался
с письмом, расшифровывал пароли на соединение с провайдером (Dial-Up) и
отправлял их на адрес ispp@usa.net.</LI>
</OL>

<H3><I>Наличие зависимости во времени обработки ключей</I></H3>

<P>Это сравнительно новый аспект недостаточно корректной реализации криптоалгоритмов,
рассмотренный в статье [<A HREF="#l2" target="_self">2</A>]. Там показано, что многие
криптосистемы неодинаково быстро обрабатывают разные входные данные. Это
происходит как из-за аппаратных (разное количество тактов на операцию,
попадание в процессорный кэш и т.п.), так и программных причин (особенно
при оптимизации программы по времени). Время может зависеть как от ключа
шифрования, так и (рас)шифруемых данных. </P>

<P>Поэтому злоумышленник, обладая детальной информацией о реализации криптоалгоритма,
имея зашифрованные данные, и будучи способным каким-то образом измерять
время обработки этих данных (например, анализируя время отправки пакетов
с данными), может попытаться подобрать секретный ключ. В работе подробно
описывается тактика атак на системы, реализующие алгоритмы RSA, <A HREF="http://www.rsa.com/rsalabs/newfaq/q24.html">Диффи-Хеллмана</A>
и <A HREF="http://www.rsa.com/rsalabs/newfaq/q26.html">DSS</A>, причем
ключ можно получать, уточняя бит за битом, а количество необходимых измерений
времени прямо пропорционально длине ключа.</P>

<P>И хотя пока не удалось довести эти исследования до конкретного результата
(вычислить секретный ключ), этот пример показывает, что программирование
систем критического назначения (в т.ч. и криптосистем) должно быть особенно
тщательным и, возможно, для этого необходимо применять особые защитные
методы программирования и специализированные средства разработки (особенно
компиляторы).</P>

<H3><I>Ошибки в программной реализации</I></H3>

<P>Ясно, что пока программы будут писаться людьми, этот фактор всегда будет
иметь место. Хороший пример - ОС Novell Netware 3.12, где, несмотря на
достаточно продуманную систему аутентификации, при которой, по заявлениям
фирмы <I>Novell</I>, <I>&quot;нешифрованный пароль никогда не передается
по сети&quot;</I>, удалось найти ошибку в программе <TT>SYSCON</TT> v.
3.76, при которой пароль именно в открытом виде попадает в один из сетевых
пакетов. Этого не наблюдается ни с более ранними, ни с более поздними версиями
этой программы, что позволяет говорить именно о чисто программистской ошибке.
Этот ошибка проявляется только если супервизор меняет пароль кому-либо
(в том числе и себе). Видимо, каким-то образом в сетевой пакет попадает
клавиатурный буфер.</P>

<H3><I>Наличие люков</I></H3>

<P>Причины наличия люков в криптосистемах очевидны: разработчик хочет иметь
контроль над обрабатываемой в его системе информацией и оставляет для себя
возможность расшифровывать ее, не зная ключа пользователя. Возможно также,
что они используются для отладки и по какой-то причине не убираются из
конечного продукта. Естественно, что это рано или поздно становится известным
достаточно большому кругу лиц и ценность такой криптосистемы становится
почти нулевой. Самыми известными примерами здесь являются <TT>AWARD BIOS</TT>
(до версии 4.51PG) с его универсальным паролем &quot;<I>AWARD_SW&quot;</I>
и СУБД <TT><A HREF="http://www.borland.com/paradox/">Paradox</A> </TT>фирмы
<A HREF="http://www.borland.com"><I>Borland Internationa</I>l</A>, также
имеющая &quot;суперпароли&quot; &quot;<I>jIGGAe&quot;</I> и &quot;<I>nx66ppx&quot;</I>.</P>

<P>Вплотную к наличию люков в реализации (очевидно, что в этом случае они
используют явно нестойкие алгоритмы или хранят ключ вместе с данными) примыкают
алгоритмы, дающие возможность третьему лицу читать зашифрованное сообщение,
как это сделано в нашумевшем проекте <TT><A HREF="http://epic.org/crypto/clipper/">CLIPPER</A></TT>,
где третьим лицом выступает государство, всегда любящее совать нос в тайны
своих граждан.</P>

<H3><I>Недостатки датчика случайных чисел (ДСЧ)</I></H3>

<P>Хороший, математически проверенный и корректно реализованный ДСЧ также
важен для криптосистемы, как и хороший, математически стойкий и корректный
криптоалгоритм, иначе его недостатки могут повлиять на общую криптостойкость
системы. При этом для моделирования ДСЧ на ЭВМ обычно применяют датчики
псевдослучайных чисел (ПСЧ), характеризующиеся периодом, разбросом, а также
необходимостью его инициализации (<I>seed</I>). Применение ПСЧ для криптосистем
вообще нельзя признать удачным решением, поэтому хорошие криптосистемы
применяют для этих целей физический ДСЧ (специальную плату), или, по крайней
мере, вырабатывают число для инициализации ПСЧ с помощью физических величин
(например, времени нажатия на клавиши пользователем).</P>

<P><I>Малый период </I>и <I>плохой разброс </I>относятся к математическим
недостаткам ДСЧ и появляются в том случае, если по каким-то причинам выбирается
собственный ДСЧ. Иначе говоря, выбор собственного ДСЧ так же опасен, как
и выбор собственного криптоалгоритма.</P>

<P>В случае малого периода (когда псевдослучайных значений, вырабатываемых
датчиком, меньше, чем возможных значений ключа) злоумышленник может сократить
время поиска ключа, перебирая не сами ключи, а псевдослучайные значения
и генерируя из них ключи. </P>

<P>При плохом разбросе датчика злоумышленник также может уменьшить среднее
время поиска, если начнет перебор с самых вероятных значений псевдослучайных
чисел.</P>

<P>Самой распространенной ошибкой, проявляющейся и в случае хорошего ПСЧ,
является его <I>неправильная инициализация</I>. В этом случае число, используемое
для инициализации, имеет либо меньшее число бит информации, чем сам датчик,
либо вычисляется из неслучайных чисел и может быть предсказано стой или
иной степенью вероятности.</P>

<P>Такая <A HREF="http://www.ddj.com/ddj/1996/1996.01/wagner.htm">ситуация</A>
имела место в программе Netscape Navigator версии 1.1. Она инициализировала
ПСЧ, используя текущее время в секундах (<I>sec</I>) и микросекундах (<I>usec</I>),
а также идентификаторы процесса (<I>pid</I> и <I>ppid</I>). Как выяснили
исследователи Я. Голдберг и Д. Вагнер, при такой схеме как максимум получалось
47 значащих бит информации (при том, что этот датчик использовался для
получения 40- или 128 (!)-битных ключей). Но, если у злоумышленника</P>

<OL>
<OL>
<LI>была возможность перехватить пакеты, передаваемые по сети; и</LI>

<LI>был доступ (<I>account</I>) на компьютер, где запущена программа,</LI>
</OL>
</OL>

<P>то для него не составляло труда с большой степенью вероятности узнать
<I>sec</I>, <I>pid</I> и <I>ppid</I>. Если условие (2) не удовлетворялось,
то злоумышленник все равно мог попытаться установить время через сетевые
демоны <TT>time</TT>, <I>pid</I> мог бы быть получен через демон <TT>SMTP</TT>
(обычно он входит в поле <TT>Message-ID</TT>), а <I>ppid</I> либо не сильно
отличается от<I> pid</I>, либо вообще равен 1.</P>

<P>Исследователи написали программу <TT><A HREF="http://hplyot.obspm.fr:80/~dl/netscapesec/unssl.c">unssl</A></TT>,
которая, перебирая микросекунды, находила секретный 40-битный ключ в среднем
за минуту.</P>

<H2><A NAME="using"></A><B>Неправильное применение криптоалгоритмов</B></H2>

<P>Эта группа причин приводит к тому, что оказывается ненадежными криптостойкие
и корректно реализованные алгоритмы.</P>

<H3><A NAME="_Ref397431632"></A><I>Малая длина ключа</I></H3>

<P>Это самая очевидная причина. Возникает вопрос: как стойкие криптоалгоритмы
могут иметь малую длину ключа? Видимо, вследствие двух факторов:</P>

<OL>
<LI>некоторые алгоритмы могут работать с переменной длиной ключа, обеспечивая
разную криптостойкость - и именно задача разработчика выбрать необходимую
длину, исходя из желаемой криптостойкости и эффективности. Иногда на это
желание накладываются и иные обстоятельства - такие, как экспортные ограничения.</LI>

<LI>некоторые алгоритмы разрабатывались весьма давно, когда длина используемого
в них ключа считалась более чем достаточной для соблюдения нужного уровня
защиты. </LI>
</OL>

<P>С резким скачком производительности вычислительной техники сначала столкнулся
алгоритм RSA, для вскрытия которого необходимо решать задачу <A HREF="http://www.rsa.com/rsalabs/newfaq/q45.html">факторизации</A>.
В марте 1994 была закончена длившаяся в течение 8 месяцев факторизация
числа из 129 цифр (428 бит<SUP><A HREF="#s5" target="_self">6</A></SUP>). Для этого было
задействовано 600 добровольцев и 1600 машин, связанных посредством электронной
почты. Затраченное машинное время было эквивалентно примерно 5000 MIPS-лет<SUP><A HREF="#s6" target="_self">7</A></SUP>.</P>

<P>Прогресс в решении проблемы факторизации во многом связан не только
с ростом вычислительных мощностей, но и с появлением в последнее время
новых эффективных алгоритмов. (На факторизацию следующего числа из 130
цифр ушло всего 500 MIPS-лет). На сегодняшний день в принципе реально факторизовать
512-битные числа. Если вспомнить, что такие числа еще недавно использовались
в программе <TT><A HREF="http://www.pgp.com">PGP</A></TT>, то можно утверждать,
что это самая быстро развивающаяся область криптографии и теории чисел.</P>

<P>29 января 1997 фирмой <A HREF="http://www.rsa.com/rsalabs/">RSA Labs</A>
был объявлен <A HREF="http://www.rsa.com/rsalabs/97challenge/">конкурс</A>
на вскрытие симметричного алгоритма <A HREF="http://www.rsa.com/rsalabs/newfaq/q76.html">RC5</A>.
<A HREF="http://www.news.com/News/Item/0,4,7483,00.html">40-битный ключ
был вскрыт</A> через 3.5 часа после начала конкурса! (Для этого даже не
потребовалась связывать компьютеры через Интернет - хватило локальной сети
из 250 машин в Берклевском университете). Через 313 часов был <A HREF="http://www.42.org/challenge/">вскрыт
и 48-битный ключ</A>. Таким образом, всем стало очевидно, что длина ключа,
удовлетворяющая экспортным ограничениям, не может обеспечить даже минимальной
надежности. </P>

<P>Параллельно со вскрытием RC5 был дан вызов и столпу американской криптографии
- алгоритму DES, имеющему ключ в 56 бит. И он <A HREF="http://www.rsa.com/des/">пал</A>
17 июня 1997 года, через 140 дней после начала конкурса (при этом было
протестировано около 25% всех возможных ключей и затрачено примерно 450
MIPS-лет). Это было безусловно выдающееся достижение, которое означало
фактическую смерть DES как стандарта шифрования. И действительно, когда
в начала 1998 года <A HREF="http://www.rsa.com/rsalabs/des2">следующее
соревнование</A> по нахождению ключа DES привело к успеху всего за 39 дней,
национальный институт стандартов США (NIST) объявил <A HREF="http://csrc.nist.gov/encryption/aes/aes_home.htm">конкурс
на утверждение нового стандарта AES</A> (Advanced Encryption Standard).
AES должен быть полностью открытым симметричным алгоритмом с ключом размером
128, 192, 256 бит и блоком шифрования размером 128 бит.</P>

<H3><I>Ошибочный выбор класса алгоритма</I></H3>

<P>Это также весьма распространенная причина, при которой разработчик выбирает
пусть и хороший, но совершенно неподходящий к его задаче алгоритм. Чаще
всего это выбор шифрования вместо хэширования или выбор симметричного алгоритма
вместо алгоритма с открытыми ключами.</P>

<P>Примеров здесь масса - это почти все программы, ограничивающие доступ
к компьютеру паролем при его включении или загрузке, например, AMI BIOS,
хранящий вместо хэша пароля его зашифрованный вариант, который, естественно,
легко <A HREF="http://www.ssl.stu.neva.ru/psw/DOWNLOAD/amipswd.com">дешифруется</A>.</P>

<P>Во всех сетевых процедурах аутентификации естественно применять ассиметричную
криптографию, которая не позволит подобрать ключ даже при полном перехвате
трафика. Однако такие алгоритмы (из сетевых OC) пока реализует только Novell
Netware 4.x, остальные же довольствуются (в лучшем случае!) стандартной
схемой &quot;запрос-отклик&quot;, при которой можно вести достаточно быстрый
перебор по перехваченным значениям &quot;запроса&quot; и &quot;отклика&quot;.
</P>

<H3><I>Повторное наложение гаммы шифра</I></H3>

<P>Уже классическим примером стала уязвимость в Windows 3.x и первых версиях
Windows 95, связанная с шифрованием. В этом случае программисты фирмы Microsoft,
хорошо известные своими знаниями в области безопасности, применяли алгоритм
<A HREF="http://www.rsa.com/rsalabs/newfaq/q87.html">RC4</A> (представляющем
собой ни что иное, как шифрование гаммированием), не меняя гаммы, несколько
раз к разным данным - сетевым ресурсам, хранящимся в файлах типа <TT>.pwl</TT>.</P>

<P>Оказалось, что один из наборов данных файла <TT>.pwl</TT> представлял
из себя более чем специфичный текст - 20-символьное имя пользователя (в
верхнем регистре) и набор указателей на ресурсы (см. рис. 2). Таким образом,
угадав им пользователя (которое в большинстве случаев к тому же совпадает
с именем файла) можно вычислить по крайней мере 20 байт гаммы. Т.к. гамма
не меняется при шифровании других ресурсов (в этом состоит основная ошибка
применения RC4 в этом случае), могут быть вычислены первые 20 байт всех
ресурсов, в которые входит длина каждого из них. Вычислив длину, можно
найти значения указателей и тем самым прибавить еще несколько десятков
байт к угаданной гамме. Этот алгоритм реализован в известной программе
<TT><A HREF="http://www.ssl.stu.neva.ru/psw/DOWNLOAD/glide.c">glide</A></TT>.</P>

<p class="c"><IMG SRC="Image5.gif" ALT="Fig.2" HEIGHT=186 WIDTH=556></P>

<DD><B>Рис. 2. Формат файла .PWL.</B></DD>

<H3><I>Хранение ключа вместе с данными</I></H3>

<P>Эта причина приводит к тому, что данные, зашифрованные с помощью криптостойкого
и корректно реализованного алгоритма, могут быть легко дешифрованы. Это
связано со спецификой решаемой задачи, при которой невозможно вводить ключ
извне и он хранится где-то внутри в практически незашифрованном виде. Иначе
говоря, здесь наиболее уязвимым будет алгоритм шифрования не ключом, а
ключа (с помощью некоего вторичного ключа). Но так как (что опять-таки
очевидно следует из специфики задачи) этот вторичный ключ хранить извне
нельзя, то основные данные рано или поздно будут расшифрованы без использования
методов перебора.</P>

<P>Типичным примером здесь будут все WWW-, ftp-, e-mail-клиенты. Дело в
том, что для базовой (наиболее часто встречающейся) аутентификации в этих
протоколах пароль должен передаваться серверу в открытом виде. Поэтому
клиентские программы вынуждены шифровать (а не хэшировать) пароль, причем
с фиксированным ключом, чтобы не надоедать пользователю постоянными вопросами.
Отсюда следует, что где-то внутри любого броузера, почтового или ftp-клиента
(будь то Netscape Communicator, Eudora, Outlook, FAR и т.п.) лежат все
ваши пароли в практически открытом виде, и что <A HREF="http://www.ssl.stu.neva.ru/psw/crack.html#email">расшифровать</A>
их не представляет труда. (Чаще всего, кстати, пароль в таких программах
даже не шифруется, а кодируется алгоритмом типа base-64).</P>

<H2><A NAME="human"></A><B>Человеческий фактор</B></H2>

<P>В любой критической системе ошибки человека-оператора являются чуть
ли не самыми дорогостоящими и распространенными. В случае криптосистем
непрофессиональные действия пользователя сводят на нет самый стойкий криптоалгоритм
и самую корректную его реализацию и применение.</P>

<P>В первую очередь это связано с выбором паролей. Очевидно, что короткие
или осмысленные пароли легко запоминаются человеком, но они гораздо проще
для вскрытия. Использование длинных и бессмысленных паролей безусловно
лучше с точки зрения криптостойкости, но человек обычно не может их запомнить
и записывает на бумажке, которая потом либо теряется, либо попадает в руки
злоумышленнику.</P>

<P>В последние годы много внимания уделяется разрешению этого противоречия,
но рекомендации по выбору хороших паролей выходят за рамки этой статьи.</P>

<P>Именно из того, что неискушенные пользователи обычно выбирают либо короткие,
либо осмысленные пароли, существуют два метода их вскрытия: <I>атака полным
перебором и атака по словарю</I>.</P>

<P>С связи с резким ростом вычислительных мощностей атаки полным перебором
имеют гораздо больше шансов на успех, чем раньше (см. также <A HREF="#_Ref397431632" target="_self">&quot;<I>Малая
длина ключа</I>&quot;</A>). Если для системы UNIX функция crypt(), которая
отвечает за хэширование паролей, была реализована так, что выполнялась
почти 1 секунду на машину класса PDP, то за двадцать лет скорость ее вычисления
увеличилась в 15000 раз (!). Поэтому если раньше хакеры (и разработчики,
которые ограничили длину пароля 8 символами) и представить себе не могли
полный перебор, то сегодня такая атака в среднем приведет к успеху за 80
дней<SUP><A HREF="#s7" target="_self">8</A></SUP>. Скорость перебора паролей для различных
криптосистем приведена в табл. 1.</P>

<CENTER><TABLE BORDER=1 CELLPADDING=0 WIDTH="425" BORDERCOLOR="#000000" >
<TR>
<TD WIDTH="56%" VALIGN="TOP" BGCOLOR="#ffffff">
<CENTER><P>Криптосистема</P></CENTER>
</TD>

<TD WIDTH="44%" VALIGN="TOP" BGCOLOR="#ffffff">
<CENTER><P>Скорость, паролей/cек.</P></CENTER>
</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="56%">ARJ 2.50</TD>

<TD WIDTH="44%" VALIGN="TOP">
<CENTER><P>350 000</P></CENTER>
</TD>
</TR>

<TR>
<TD WIDTH="56%" VALIGN="TOP">RC5 - 56 бит</TD>

<TD WIDTH="44%" VALIGN="TOP">
<CENTER><P>150 000</P></CENTER>
</TD>
</TR>

<TR>
<TD>LM-хэш</TD>

<TD>
<CENTER><P>50 000</P></CENTER>
</TD>
</TR>

<TR>
<TD WIDTH="56%" VALIGN="TOP">Novell Netware 3.x</TD>

<TD WIDTH="44%" VALIGN="TOP">
<CENTER><P>25 000</P></CENTER>
</TD>
</TR>

<TR>
<TD>MS Office 97</TD>

<TD>
<CENTER><P>15 000</P></CENTER>
</TD>
</TR>

<TR>
<TD WIDTH="56%" VALIGN="TOP">UNIX - crypt()</TD>

<TD WIDTH="44%" VALIGN="TOP">
<CENTER><P>15 000</P></CENTER>
</TD>
</TR>

<TR>
<TD VALIGN=TOP WIDTH="56%">RAR 2.0</TD>

<TD WIDTH="44%" VALIGN="TOP">
<CENTER><P>1 000</P></CENTER>
</TD>
</TR>

<TR>
<TD WIDTH="56%" VALIGN="TOP">UNIX -MD5</TD>

<TD WIDTH="44%" VALIGN="TOP">
<CENTER><P>500</P></CENTER>
</TD>
</TR>
</TABLE></CENTER>

<DD><B>Табл. 1. Скорость полного перебора на компьютере класса Pentium/166.</B></DD>

<P>Однако вернемся на несколько лет назад, когда вычислительной мощности
для полного перебора всех паролей не хватало. Тем не менее, хакерами был
придуман остроумный метод, основанный на том, что качестве пароля человеком
выбирается существующее слово или какая-либо информация о себе или своих
знакомых (имя, дата рождения и т. п.). Ну, а поскольку в любом языке не
более 100000 слов, то их перебор займет весьма небольшое время, и от 40
до 80% существующих паролей может быть угадано с помощью такой простой
схемы, называемой &quot;атакой по словарю&quot;. (Кстати, до 80% этих паролей
может быть угадано с использованием словаря размером всего 1000 слов!).
Даже вирус Морриса (в 1988 г.!) применял такой способ, тем более что в
UNIX &quot;под рукой&quot; часто оказывается файл-словарь, обычно используемый
программами-корректорами. Что же касается &quot;собственных&quot; паролей,
то файл <TT>/etc/passwd</TT> может дать немало информации о пользователе:
его входное имя, имя и фамилию, домашний каталог. Вирус Морриса с успехом
пользовался следующими предположениями [<A HREF="#l3" target="_self">3</A>]:</P>

<UL>
<LI>в качестве пароля берется входное им пользователя;</LI>

<LI>пароль представляет собой двойной повтор имени пользователя;</LI>

<LI>то же, но прочитанное справа налево;</LI>

<LI>имя или фамилия пользователя;</LI>

<LI>то же, но в нижнем регистре. </LI>
</UL>

<P>Пусть сегодня пользователи уже понимают, что выбирать такие пароли нельзя,
но до тех пор, пока с компьютером работает человек<SUP><A HREF="#s8" target="_self">9</A></SUP>,
эксперты по компьютерной безопасности не дождутся использования таких простых
и радующих душу паролей, как <I>34jXs5U@bTa!6</I>. Поэтому даже искушенный
пользователь хитрит и выбирает такие пароли, как <I>hope1, user1997, pAsSwOrD,
toor, roottoor, parol, gfhjkm, asxz</I>. Видно, что все они, как правило,
базируются на осмысленном слове и некотором простом правиле его преобразования:
прибавить цифру, прибавить год, перевести через букву в другой регистр,
записать слово наоборот, прибавить записанное наоборот слово, записать
русское слово латинскими буквами, набрать русское слово на клавиатуре с
латинской раскладкой, составить пароль из рядом расположенных на клавиатуре
клавиш и т. п.</P>

<P>Поэтому не надо удивляться, если такой &quot;хитрый&quot; пароль будет
вскрыт хакерами - они не глупее самих пользователей, и уже вставили в свои
программы те правила, по которым может идти преобразование слов. В самых
продвинутых программах (<TT><A HREF="http://www.false.com/security/john/index.html">John
The Ripper</A></TT><I>, </I><TT><A HREF="http://www.ssl.stu.neva.ru/psw/crack.html#PCL">Password
Cracking Library</A></TT>) эти правила могут быть программируемыми и задаваться
с помощью специального языка самим хакером.</P>

<P>Приведем пример эффективности такой стратегии перебора. Во многих книгах
по безопасности предлагается выбирать в качестве надежного пароля два осмысленных
слова, разделенных некоторым знаком, например <I>&quot;good!password&quot;</I>.
Подсчитаем, за сколько времени в среднем будут сломаны такие пароли, если
такое правило включено в набор программы-взломщика (пусть словарь 10000
слов, разделительными знаками могут быть 10 цифр и 32 знака препинания
и специальных символа, машина класса Pentium со скоростью 15000 crypt/сек):<IMG SRC="Image6.gif" ALT="(10000*(10+32)*10000)/(15000*2)" HEIGHT=51 WIDTH=194 ALIGN=ABSCENTER>=140
000 секунд или менее 1.5 дней!</P>

<H2>Заключение </H2>

<P>С момента начала написания этой статьи в 1996 году положение в применении
средств криптографии в прикладных программах бесспорно меняется в лучшую
сторону. Постепенно разработчики осознают необходимость применения зарекомендовавших
себя алгоритмов, сдвигаются с мертвой точки позиции некоторых стран в вопросе
экспорта криптоалгоритмов, разрабатываются новые алгоритмы и стандарты
с большей длиной ключа и эффективностью для реализации на всех типах процессоров,
от 8-битных до RISC.</P>

<P>Тем не менее, остается огромная пропасть между уровнем стойкости и надежности
существующего сейчас ПО, применяющего криптоалгоритмы, в котором до сих
пор находятся &quot;детские&quot; дыры (последний пример - реализация PPTP
от Microsoft [<A HREF="#l4" target="_self">4</A>]) и тем уровнем криптостойкости, который
демонстрируют последние, независимо проанализированные ведущими криптоаналитиками
алгоритмы и протоколы, где серьезной уязвимостью считается, например, та,
что требует 2<SUP>65</SUP> блоков шифрованного текста и затем 2<SUP>58</SUP>
перебора вариантов или одного открытого текста, зашифрованного 2<SUP>33</SUP>
разными, но зависимыми друг от друга ключами и затем сложности анализа,
равного 2<SUP>57</SUP>[<A HREF="#l5" target="_self">5</A>].</P>

<P>Хочется надеяться, что будущие реализации и применение этих алгоритмов
сохранят столь высокую степень их надежности. </P>

<H2><B>Резюме</B></H2>

<P>Можно выделить 4 основных группы причин ненадежности криптографических
систем: применение нестойких алгоритмов, неправильная реализация или применение
криптоалгоритмов, а также человеческий фактор. При этом видна четкая параллель
между ними и причинами нарушения безопасности вычислительных систем. </P>

<P>Из-за описанных причин имелись или имеются проблемы в безопасности у
всех классов программных продуктов, использующие криптоалгоритмы, будь
то операционные системы; криптопротоколы; клиенты и сервера, их поддерживающие;
офисные программы; пользовательские утилиты шифрования; популярные архиваторы.</P>

<P>Для того, чтобы грамотно реализовать собственную криптосистему, необходимо
не только ознакомится с ошибками других и понять причины, по которым они
произошли, но и, возможно, применять особые защитные приемы программирования
и специализированные средства разработки.
  <hr width=50%>
  <p class="l"><a name="s9"></a><sup>1</sup> <font size="-1">Под криптостойкостью
  здесь и далее будет пониматься количество
  вариантов для нахождения ключа перебором.</font><br>
  <a name="s1"></a><font size="-1"><sup>2 </sup>Это было до недавнего
  времени. Сейчас - 56 бит.</font><br>
  <a name="s2"></a><font size="-1"><sup>3 </sup>[ ] - целая часть
  (ближайшее целое снизу).</font><br>
  <a name="s3"></a><font size="-1"><sup>4</sup> ] [ - ближайшее целое
  сверху.</font><br>
  <a name="s4"></a><font size="-1"><sup>5</sup> Ясно, что и здесь и в
  примере выше получаются одни и те же числа, но за
  счет округления в разные стороны оказывается
  разница в 1 символ.</font><br>
  <a name="s5"></a><font size="-1"><sup>6</sup> что приблизительно
  соответствует 56 битам для симметричных
  алгоритмов. </font><br>
  <a name="s6"></a><font size="-1"><sup>7</sup> миллион инструкций в
  секунду в течении года. </font><br>
  <a name="s7"></a><font size="-1"><sup>8 </sup>Используя специальные
  платы или распараллеливание, это время можно
  уменьшить на несколько порядков. </font><br>
  <a name="s8"></a><font size="-1"><sup>9</sup> :-) </font><br>
  <hr width=50%>
  <h2>Литература.</h2>
  <p class="l">
<A NAME="l1"></A>1. <A HREF="http://www.ssl.stu.neva.ru/ssl/koi/publications/book-6.html">Теория
и практика обеспечения информационной безопасности. Под редакцией Зегжды
П.Д.</A> - М., Яхтсмен, 1996.<br>

<A NAME="l2"></A>2. <A HREF="http://www.ssl.stu.neva.ru/psw/crypto/timing.html">П.
Кочер. Временной анализ реализаций Диффи-Хеллмана, RSA, DSS и других систем</A><br>

<A NAME="l3"></A>3. <A HREF="ftp://coast.cs.purdue.edu/pub/doc/morris_worm/mit.PS.Z">Mark
W. Eichin, Jon A. Rochils. With Microscope and Tweezers: An Analysis of
the Internet virus of November 1988.</A><br>

<A NAME="l4"></A>4. <A HREF="http://www.ssl.stu.neva.ru/psw/crypto/pptp.html">Б.
Шнайер, П. Мюдж. Криптоанализ протокола PPTP от Microsoft</A>.<br>

<A NAME="l5"></A>5. <A HREF="http://www.cs.technion.ac.il/users/wwwb/cgi-bin/tr-get.cgi/1998/CS/CS0928.ps.gz">Eli
Biham, Lars R. Knudsen. Cryptanalysis of the ANSI X9.52 CBCM Mode. Proceedings
of Eurocrypt'98</A>.<br>
  <h2>Дополнительные ссылки.</h2>
  <p class="l"><a href="http://infoart.kazan.ru/it/talk/crypto/index.htm">Баpичев Сеpгей.
  Kpиптогpафия без секpетов.</a><br>
  <a href="http://www.counterpane.com/whycrypto.html">Bruce Schneier. Why Cryptography Is
  Harder Than It Looks</a>    
  <p class="l"><tt>&copy; Павел Семьянов, 1996-98 г.</tt><br>
  <tt>e-mail: <a href="mailto:psw@ssl.stu.neva.ru?subject=Crypto systems">psw@ssl.stu.neva.ru</tt></a><br>
  <tt>WWW: <a href="http://www.ssl.stu.neva.ru/psw/">http://www.ssl.stu.neva.ru/psw</tt></a><br>
<br>
          <hr>
       <TABLE>          <TR>             <TD><A HREF="security_.html"><IMG SRC="back.gif" ALT="<== Back to main page" BORDER=0 HEIGHT=31 WIDTH=191></A></TD>
<td><a href="http://www.lgg.ru/~svp/cgi-bin2/main.txt"><img src="http://www.lgg.ru/~svp/cgi-bin2/logger.cgi?why_not_safe_.html" WIDTH=10 HEIGHT=10 ALT="" BORDER=0 ></a> </td>
          </TR>
       </TABLE>
    </td>
  </tr>
</table>
</body></html>