<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">

<HTML>

<HEAD>
<TITLE>Hack & Crack</TITLE>
</HEAD>

<BODY BACKGROUND="" BGCOLOR="#ffffff" TEXT="#000000" LINK="#0000ff" VLINK="#800080" ALINK="#ff0000">
<font face="Times New Roman">
<CENTER><FONT COLOR=ff0000 SIZE="7"><B>BEPCTAK</B></FONT><BR>
<b><FONT COLOR=#0000ff SIZE="+1">Крэки для ДОС</FONT></b><BR></CENTER>
<CENTER>(C) Master A. Pixel (SLY FOX)</CENTER><BR>

<TABLE BGCOLOR="#ffaaff" WIDTH=40%><TR><TD>&nbsp;Креки для ДОС</TD></TR></TABLE>
<OL>
<LI><a href="#1201_1">УПРАВЛЕНИЕ</a> <I> памятью ДОС. Сервис ДОС. Загрузка и выполнение.</I>
<LI><a href="#1201_2">СИСТЕМА </a> <I>прерываний. Перeхват перываний. Резидентные программы.</I>
<LI><a href="#1201_3">СЪЕМ ДАМПОВ</a> <I>  памяти и анализ результатов.</I>
<LI><a href="#1201_4">ЗАГОТОВКИ</a> <I> крекеров. Тяжелые случаи :)</I>
</OL>
<TABLE BGCOLOR="#55aaff" WIDTH=40%><TR><TD>&nbsp;Прочее</TD></TR></TABLE>
<OL>
<LI><a href="#1201_5">ТАБЛИЦЫ </a> <I> вспомогательные</I><P>
</OL>
<HR>
<A NAME="1201_1"></A>
<TABLE BGCOLOR="#c0c0c0" WIDTH=40%><TR><TD>&nbsp;<FONT COLOR=#ffffff> 1. Управление памятью ДОС.</FONT></TD></TR></TABLE>
&nbsp;&nbsp;Типично ДОС выделяет стартуемой задаче всю доступную оперативную память.
По выгрузке завершившейся задачи ДОС освобождает прежде занимаемую ей память.
Однако некоторая часть памяти постоянно занята ядром ДОСа и программами сервиса ввода/вывода.
Для поддержки их неприкосновенности ДОС имеет средства рапределения памяти и способы
оставить память неприкосновенной после выполнения задачи. В этом случае программа,
завершаеясь специальным образом, оставляет указанную ею область памяти помеченной как
используемая. Эта область памяти урезается из общедоступного объема памяти и в дальнейшем
ДОС не использует ее. Поскольку в ДОС принята линейная модель памяти, средства свопирования
или переноса кода не предусмотрены, и программы занимают память от нижней границы доступного
пространтства.  Таким образом, прочие программы просто начинают грузиться выше границы
занятого устойчивыми модулями пространства. Для корректной обработки памяти и файлов ДОС держит
специальные системные таблицы, из которых для креков интерес представляют MCB (memory
control block) и PSP (program segment prefix). MCB  создается ДОСом для каждого запроса выделения
памяти (при старте программы ДОС сам производит такой запрос), и удаляется при запросе
освободить память (опять же ДОС сам вызывает запрос освободить память по завершенни задачи).
В случае завершения программы специальным образом TSR (terminate & stay resident) запрос
освобождения не производится, и созданный
MCB остается в памяти. MCB организованы таким образом, что каждый блок имеет в специальном поле
ссылку на следующий блок или же признак, что он последний в цепочке. Это позволяет просмотреть
всю цепочку блоков, и узнать, чем занята память ДОС в данный момент. <BR>
PSP создается для загружаемой задачи и собержит некоторую полезную как для нее, так и для ДОСа 
информацию, типа указателя на командную строку, переданную программе. Имеет длину 256 байт
и предшествует любой программе. При старте программы на него указывает DS:0000. <BR>
Структуру таблиц смотрите в <A HREF=#1201_5>"таблицы вспомогательные"</A><P>.

<A NAME="1201_2"></A>
<TABLE BGCOLOR="#c0c0c0" WIDTH=40%><TR><TD>&nbsp;<FONT COLOR=#ffffff> 2. Система прерываний. Перехват перываний.</FONT></TD></TR></TABLE>
&nbsp;&nbsp;Система прерываний компьютеров IBM PC представляет из себя программное средсво
переключения контекста задачи для вызова обслуживающих подпрограмм на фоне работы
задачи, так, что она этого и не замечает. Прерывания бывают аппаратные и программные. Аппаратные
возникают вследствие запросов оборудования на обслуживание процессором. Например, прерывание
IRQ 1 возбуждается клавиатурой при нажатии/отпускании клавиши. Для арбитража аппаратных прерываний,
если их случилось сразу несколько, запросы от оборудования проходят через контроллер прерываний,
который запрограммирован на определенный приоритет (порядок) их выполнения. Контроллер 
также может совсем отменять реагирование на некотрорые из них (маскирование). Аппаратные
прерывания IRQ преводятся  в программные INT (смари таблицы), и таким образом, обрабатываются
неотличимо от программных. Программные прерывания инициируюся выполняемой инструкцией процессора
INT X , где Х - номер прерывания. Этот номер указывает на строку таблицы векторов прерываний,
хранящуюся в первом К памяти. Каждая строка таблицы содержит два слова: сегмент и смещение, и имеет,
таким образом, длину в 4 байта. Сегмент и смещение указывают на точку входа подпрограммы, обслуживающей
данное прерывание. Таким образом, для получения адреса в таблице (вектора) процессор просто умножает
номер прерывания на 4 (сдвигая его на 2 бита влево).<BR>
Обработка происходит следующим образом: получив инструкцию INT X, или сигнал от контроллера прерываний,
процессор сохраняет в стеке флаги, текуший сегмент кода CS и указатель IP, читает в таблице 
прерываний по адресу Х * 4 сегмент и смещение обработчика, загружает их в CS и IP и выполняет
код обработчика. Обработчик заканчивается инструкцией IRET, по которой процессор достает
из стека старые IP, CS и флаги и, зангузив их, возвращается к выполнению преравнной задачи.<BR>
Первые 32 прерывания зарезервированы для обслуживания оборудования, а остальные используются
программами на свое усмотрение. При загрузке компьютера BIOS инициализирет таблицу прерываний
таким образом, что вектора обслуживания оборудования указывают на процедуры в BIOS. При этом некоторые
запросы не обслуживаются, и их вектора указывают на заглушку (инструкция IRET), например,
прерывание таймера 1Сh. Программы могут установить свой обработчик того или иного прерывания,
заменив имеющийся ветор в таблице на свой, указывающий на свою процедуру обработки. <BR>
При этом возможны 3 варианта:<BR>
<table border=1>
<tr>
<td>Сначала наш обработчик, потом возвращаем прежний</td>
<td>Сначала прежний обработчик, потом наш.</td>
<td>Только наша обработка.</td>
</tr>
<tr>
<td>process:<BR>
;...<BR>
;...<BR>
;...<BR>
jmp old_int<BR>
</td>
<td>
process:<BR>
pushf<BR>
call old_int<BR>
;...<BR>
;...<BR>
;...<BR>
iret
</td>
<td>
process:<BR>
;...<BR>
;...<BR>
;...<BR>
iret
</td>
</tr>
</table>
Если написать программу, резидентно оставляющую в памяти участок кода с обработчиком, то
такой обработчик прерывания будет действовать и после завершения установившей его программы.
Установка резидентной части программы наглядно показана в примерах, помещенных далее.
Основная стратегия установки/перехвата: прочитать вектор перехватывемого прерывания и
сохранить в переменной для будущего использования (old_int), прописать вектор, указывающий
на наш обработчик, завершиться, оставив резидентную часть (обработчик).<P>
<U>Замечание:</U> контроллер прерываний, обрабатывающий аппаратные прерывания, должен
знать, что прерывание принято и пущено в обработку, для правильной работы своей схемы
приоритетов. Поэтому, когда вы обрабатываете <I>аппаратные</I> прерывания, следует послать
в контроллер сигнал подтвержения, типа такого:<BR>
&nbsp;&nbsp;&nbsp;&nbsp;mov ah,20h<BR>
&nbsp;&nbsp;&nbsp;&nbsp;out 20h,ah<BR>
- в противном случае обработка этого прерывания будет нарушена. Если же вы передаете управление
стандартному обработчику, то он сам выдаст такое подвердение, и вам оно не нужно.<P>


<A NAME="1201_3"></A>
<TABLE BGCOLOR="#c0c0c0" WIDTH=40%><TR><TD>&nbsp;<FONT COLOR=#ffffff> 3. Съем дампов памяти. Анализ результатов.</FONT></TD></TR></TABLE>

&nbsp;&nbsp; Для крекования игрулек или защищенных программ наиболее часто используется
способ заненсения в определенную ячейку памяти желаемого значения. Например, это может быть
количество жизней или признак введенности правильного пароля. Как говорилось выше, ДОС отводит
стартующим программам всю доступную на данный момент память. В ней и размещается код
программы и данные, которые она может загружать вместе с кодом или подкачивать с диска.
В каком-то месте памяти хранятся и интересующие крекера значения. Для обнаружения алресов
этих ячеек используется метод съема дампов памяти в характерные моменты, когда хранимое значение
изменяется, и последующего сравнения дампов между собой с целью отыскать места этих различий.
Например, вы снимаете дампы памяти в моменты, когда у вас было 4, 3, 2 и 1 жизни. Запустив
программу - компаратор, вы получаете файл, содержащий все различия межу этими дампами.
Среди них надо отыскать значения, похожие на целевые. Например, вы находите строку:<P>
XXXX:XXXX&nbsp;&nbsp;&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;1<P>
Это напоминает количество жизней в момент снятия каждого дампа. Стало быть, адрес ячейки,
хранящей количество жизней, равен XXXX:XXXX.<BR>
Следует учесть, что количество совпадений может быть больше одного по причине различных
эховых переменных. Найти среди них действительно управляющую - дело эксперимента. Кроме
того, по ходу игры меняется так много параметров, что зачастую отличаются до половины всего
содержимого дампов, так что используйте несложную программу, помогающую найти ожидаемые
результаты (в пакете <a href="tppmsgs/msgs0.htm#9" tppabs="http://www.chat.ru/~sly_fox/ip.zip">Immortal Player</a> отсутствует, к сожалению). Вы можете
скачать <a href="tppmsgs/msgs0.htm#10" tppabs="http://www.chat.ru/~sly_fox/ip_add.zip%22">мой вариант</a> программы или написать свою. При этом даже программа на интерпретируемом
бейсике работает куда быстрее человека.<BR>
&nbsp;&nbsp;Далее пишем простую прогу, которая вешает резидентный обработчик на прерывание
таймера, происходящее примерно 18 раз в секунду, и с каждым разом обработчик будет записывать
по указанному нами адресу указанное значение. Таким образом ваша "жизнь", не успев уменьшиться,
будет тут же восполняться. Некоторые игры терпят даже превышение обычных для них жизней до
небывалых количеств (скажем, вместо четырех - аж 65535 штук!).<P>

<A NAME="1201_4"></A>
<TABLE BGCOLOR="#c0c0c0" WIDTH=40%><TR><TD>&nbsp;<FONT COLOR=#ffffff> 4. Заготовки крекеров и тяжелые случаи</FONT></TD></TR></TABLE>
&nbsp;&nbsp;В конце этого параграфа помещен для скачки архив заготовок крекеров. Там
есть самые простые ломалки и более хитроумные варианты. Я снадбил их комментариями,
помогающими разобраться в назначении инструкций. Тем не менее пару слов о хитрых приемах,
когда простые способы не работают или вешают систему. Это случается тогда, когда игрушка
не держит все данные сразу в памяти, а подгружает их с диска в виде фалов данных или
оверлеев. На счастье, в осносном попадаются игрушки, имеющие простую структуру типа
ИНТРО/ИГРА/ФИНАЛ. Соответственно был написан крекер, активирующийся только после прохождения
интро-заставки по нажатию кнопки ALT. Кроме того, он предохранен от случайной активации, проверяя
наличие атакуемой программы в памяти, и, таким обрахом, может быть загружен и сидеть в памяти,
дожидаясь игрушку, сколь угодно долго. Проверку он производит, просматривая обсуждавшиеся
МСВ, проверяя, является ли владельцем МСВ программа. Это он делает, "надкусывая" краешек кода,
на который указывает МСВ, и проверяя, похож ли он на PSP. Если код "на вкус" как PSP, то берется и 
сравнивается с указанным имя программы (для простоты я не проверяю всю строку, а беру первый
символ, именуя прогу так, чтобы ее имя начиналась на какую-нибудь кракозяблу типа @). Если прога, начинающаяся
с такой масямбы, есть в памяти, крекер активируется. В примерах есть крекер для "принца персии 2",
файл которого prince.exe следует переименовать в _prince.exe. Ключевой символ "_", в данном случае.<BR>
К другим тяжелым случаям относится проверка перехватов. Обычно все игрушки ставят свой
обработчик прерывания клавиатуры, позволяющий им лучше реагировать на клавиши (и игнорировать
нажатия типа CTRL+C). Вот иногда игрушка проверяет, остался на месте ее обработчик,
и если это не так, ставит его заново. Это не дает нам буквально никакой возможности отнять
у нее прерывание без нарушения ее нормальной работы. Даже если мы предусмотрим свою проверку
и тоже будем переустанавливать свой обработчик, то прерывание будет каждый раз переходить
из рук в руки :). Выход из этого положения - каджый раз ставить свой обработчик, а потом возвращать
игрушкин так, чтобы она ничего не заметила. На самом деле я встречал такой трабл не игушке,
а в одной из систем защит...

<CENTER><a href="tppmsgs/msgs0.htm#8" tppabs="http://www.chat.ru/~sly_fox/ip_asm.zip">Download заготовок</a></CENTER>
<P>

<a name="1201_5"></a>
<TABLE BGCOLOR="#55aaff" WIDTH=40%><TR><TD><FONT COLOR="ffffff">&nbsp;Таблицы вспомогательные</font></TD></TR></TABLE>
<P>
Структура PSP<P>
<TABLE BORDER=1>
<TR>
<TD Align=center>смещение</TD>
<TD>тип</TD>
<TD align=center>длинa, байт</TD>
<TD align=center>содержание поля</TD>
</TR>
<TR>
<TD>0</TD>
<TD>DW</TD>
<TD align=center>2</TD>
<TD>код команды INT 20h</TD>
</TR>
<TR>
<TD>2</TD>
<TD>DW</TD>
<TD align=center>2</TD>
<TD>общий размер памяти</TD>
	</TR>
	<TR>
		<TD>
			4
		</TD>
		<TD>
			DB
		</TD>
		<TD>
			<CENTER>1</CENTER>
		</TD>
		<TD>
			резерв
		</TD>
	</TR>
	<TR>
		<TD>
			5
		</TD>
		<TD>
			DB
		</TD>
		<TD>
			<CENTER>5 байт</CENTER>
		</TD>
		<TD>
			код команды call far к диспетчеру ДОСа
		</TD>
	</TR>
	<TR>
		<TD>
			0Ah
		</TD>
		<TD>
			DW
		</TD>
		<TD>
			<CENTER>2</CENTER>
		</TD>
		<TD>
			адрес окончания программы
		</TD>
	</TR>
	<TR>
		<TD>
			0Ch
		</TD>
		<TD>
			DW
		</TD>
		<TD>
			<CENTER>2</CENTER>
		</TD>
		<TD>
			сегмент окончания программы
		</TD>
	</TR>
	<TR>
		<TD>
			0Eh
		</TD>
		<TD>
			DW
		</TD>
		<TD>
			<CENTER>2</CENTER>
		</TD>
		<TD>
			адрес обработчика Ctrl+Break
		</TD>
	</TR>
	<TR>
		<TD>
			10h
		</TD>
		<TD>
			DW
		</TD>
		<TD>
			<CENTER>2</CENTER>
		</TD>
		<TD>
			его сегмент
		</TD>
	</TR>
	<TR>
		<TD>
			12h
		</TD>
		<TD>
			DW
		</TD>
		<TD>
			<CENTER>2</CENTER>
		</TD>
		<TD>
			адрес обработчика критичесих ошибок
		</TD>
	</TR>
	<TR>
		<TD>
			14h
		</TD>
		<TD>
			DW
		</TD>
		<TD>
			<CENTER>2</CENTER>
		</TD>
		<TD>
			его сегмент
		</TD>
	</TR>
	<TR>
		<TD>
			16h
		</TD>
		<TD>
			DW
		</TD>
		<TD>
			<CENTER>2</CENTER>
		</TD>
		<TD>
			сегмент PSP родительского процесса
		</TD>
	</TR>
	<TR>
		<TD>
			18h
		</TD>
		<TD>
			DW
		</TD>
		<TD>
			<CENTER>2</CENTER>
		</TD>
		<TD>
			резерв
		</TD>
	</TR>

</TABLE>
<P>
Cтруктура MCB (для MS-DOS версий от 4.0 и старше)<P>
<TABLE  BORDER=1>
	<TR>
		<TD>смещение</TD>
		<TD>тип</TD>
		<TD>длина</TD>
		<TD>cодержание поля
		</TD>
	</TR>
	<TR>
		<TD>
			0
		</TD>
		<TD>
			DB
		</TD>
		<TD>
			1
		</TD>
		<TD>
			сигнатура 4Dh - последний, 5Ah - не последний
		</TD>
	</TR>
	<TR>
		<TD>
			1
		</TD>
		<TD>
			DW
		</TD>
		<TD>
			2
		</TD>
		<TD>
			сегмент владельца блока
		</TD>
	</TR>
	<TR>
		<TD>
			3
		</TD>
		<TD>
			DW
		</TD>
		<TD>
			2
		</TD>
		<TD>
			смешение в параграфах от конца текущего до начала следующего MCB
		</TD>
	</TR>
	<TR>
		<TD>
			5
		</TD>
		<TD>
			DB
		</TD>
		<TD>
			3 байта
		</TD>
		<TD>
			резерв
		</TD>
	</TR>
	<TR>
		<TD>
			8
		</TD>
		<TD>
			DB
		</TD>
		<TD>
			8 байт
		</TD>
		<TD>
			имя владельца
		</TD>
	</TR>
</TABLE>
<P>
Таблица соответствия IRQ и INT
<P>
<TABLE BORDER=1>
	<TR>
		<TD ALIGN=CENTER>
			<B>аппаратное</B>
		</TD>
		<TD ALIGN=CENTER>
			<B>программное</B>
		</TD>
	</TR>
	<TR>
		<TD ALIGN=CENTER>
			IRQ 0
		</TD>
		<TD ALIGN=CENTER>
			INT 8
		</TD>
	</TR>
	<TR>
		<TD ALIGN=CENTER>
			IRQ 1
		</TD>
		<TD ALIGN=CENTER>
			INT 9
		</TD>
	</TR>
	<TR>
		<TD ALIGN=CENTER>
			IRQ 2
		</TD>
		<TD ALIGN=CENTER>
			INT A
		</TD>
	</TR>
	<TR>
		<TD ALIGN=CENTER>
			IRQ 3
		</TD>
		<TD ALIGN=CENTER>
			INT B
		</TD>
	</TR>
	<TR>
		<TD ALIGN=CENTER>
			IRQ 4
		</TD>
		<TD ALIGN=CENTER>
			INT C
		</TD>
	</TR>
	<TR>
		<TD ALIGN=CENTER>
			IRQ 5
		</TD>
		<TD ALIGN=CENTER>
			INT D
		</TD>
	</TR>
	<TR>
		<TD ALIGN=CENTER>
			IRQ 6
		</TD>
		<TD ALIGN=CENTER>
			INT E
		</TD>
	</TR>
	<TR>
		<TD ALIGN=CENTER>
			IRQ 7
		</TD>
		<TD ALIGN=CENTER>
			INT F
		</TD>
	</TR>
</TABLE>
<P>

<CENTER><a href="1000.html" tppabs="http://www.chat.ru/~sly_fox/1000.html">Назад</a>
<!--&nbsp;&nbsp;&nbsp;&nbsp;<a href="mailto:sipsik@chat.ru">sipsik@chat.ru</a>-->
</CENTER>
<BR>

<P>
</font>
</BODY>

</HTML>
